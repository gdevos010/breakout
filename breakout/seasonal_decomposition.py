import os

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose


def seasonal_decomposition_breakout(
    data: pd.DataFrame | np.ndarray,
    value_column: str = "value",
    date_column: str = "date",
    period: int = 365,
    threshold: float = 2.5,
) -> tuple[list[int], pd.DataFrame]:
    """
    Perform seasonal decomposition and detect breakouts based on residuals.

    Parameters:
    - data (Union[pd.DataFrame, np.ndarray]): The time series data generated by generate_timeseries_with_breakouts
    - value_column (str): Name of the column containing the time series values (used only for DataFrame input)
    - date_column (str): Name of the column containing the dates (used only for DataFrame input)
    - period (int): The number of time steps in each seasonal cycle
    - threshold (float): Number of standard deviations to consider as a breakout

    Returns:
    - Tuple[List[int], pd.DataFrame]:
        - List of indices where breakouts were detected
        - DataFrame containing the decomposed components (trend, seasonal, residual)
    """
    # Input validation and conversion
    if isinstance(data, pd.DataFrame):
        if value_column not in data.columns or date_column not in data.columns:
            raise ValueError(
                f"Columns '{value_column}' or '{date_column}' not found in DataFrame"
            )
        # Ensure the data is sorted by date
        data = data.sort_values(date_column)
        time_series = data[value_column]
        dates = data[date_column]
    elif isinstance(data, np.ndarray):
        if data.ndim != 1:
            raise ValueError("NumPy array input must be 1-dimensional")
        time_series = data
        dates = pd.date_range(
            start="2020-01-01", periods=len(time_series)
        )  # Assuming daily frequency

    else:
        raise ValueError("Input data must be a pandas DataFrame or NumPy array")

    # Perform seasonal decomposition
    decomposition = seasonal_decompose(time_series, model="additive", period=period)

    # Create a DataFrame with the decomposed components
    decomposed_df = pd.DataFrame(
        {
            "trend": decomposition.trend,
            "seasonal": decomposition.seasonal,
            "residual": decomposition.resid,
            "observed": decomposition.observed,
        }
    )
    decomposed_df["date"] = dates

    # Calculate the standard deviation of the residuals
    residual_std = np.std(decomposed_df["residual"].dropna())

    # Detect breakouts based on residuals
    breakouts = []
    for i, residual in enumerate(decomposed_df["residual"]):
        if abs(residual) > threshold * residual_std:
            breakouts.append(i)

    return breakouts, decomposed_df


def plot_seasonal_decomposition_breakout(decomposed_data_df: pd.DataFrame) -> None:
    plt.figure(figsize=(12, 10))
    plt.subplot(411)
    plt.plot(decomposed_data_df["date"], decomposed_data_df["observed"])
    plt.title("Observed")
    plt.subplot(412)
    plt.plot(decomposed_data_df["date"], decomposed_data_df["trend"])
    plt.title("Trend")
    plt.subplot(413)
    plt.plot(decomposed_data_df["date"], decomposed_data_df["seasonal"])
    plt.title("Seasonal")
    plt.subplot(414)
    plt.plot(decomposed_data_df["date"], decomposed_data_df["residual"])
    plt.title("Residual")
    plt.tight_layout()
    current_file_path = os.path.abspath(__file__)
    plt.savefig(
        f"{current_file_path}/../../plots/seasonal_decomposition_breakout_data.png"
    )
    plt.clf()
